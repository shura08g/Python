"""
    Наибольшая подпоследовательность
    A, B - массив чисел len(A0 == N, len(B)) == M
    Подпоследовательность A: C, содержащий элементы A
    в исходном порядке но возможно не все
    [] - подпоследовательность любой A
    Fij - длина наибольшей возможность подпоследовательности
        частей A и  B: A[0:i] - часть A, первые i элементов
                       B[0:j] - часть B, первые j элементов
    -----------------------
    Fij = { 1 + F(i-1)(j-1),        ai = bj  [a1, a2 ... ai-1, ai]
          { max(Fi(j-1), F(i-1)j), ai <> bj  [b1, b2 ... bj-1, bj]
    -----------------------
    F0j = 0, Fi0 =0
    lcs - largest common subsequence
"""


def lcs(A, B):
    F = [[0] * (len(B) + 1) for i in range(len(A) + 1)]
    for i in range(1, len(A) + 1):
        for j in range(1, len(B) + 1):
            if A[i - 1] == B[j - 1]:
                F[i][j] = 1 + F[i - 1][j - 1]
            else:
                F[i][j] = max(F[i - 1][j], F[i][j - 1])
    return F[-1][-1]  # из последней строки последний элемент (len(F) -1)


"""
    Наибольшая возростающая подпоследовательность (НВП)
    Fij - НВП для части A[0:i], которая заканчивается и
          содержит элемент ai = A[i-1]
    ----------------------------------
    Fi = max(Fj) + 1   [a1, a2 ... ai-1, ai]
          (j < i)      [a1, a2 ... aj]
          (ai > aj)
    F0 = 0
"""


def gis(A):
    F = [0] * (len(A) + 1)
    for i in range(1, len(A) + 1):
        m = 0
        for j in range(0, i):
            if A[i] > A[j] and F[j] > m:
                m = F[j]
        F[i] = m + 1
    return F(len(A))
